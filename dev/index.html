<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flatten.jl · Flatten.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Flatten.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Flatten.jl</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Flatten.jl</a></li></ul><a class="edit-page" href="https://github.com/rafaqz/Flatten.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Flatten.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Flatten.jl-1" href="#Flatten.jl-1">Flatten.jl</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.Flatten" href="#Flatten.Flatten"><code>Flatten.Flatten</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Flatten.jl converts data between nested and flat structures, using <code>flatten()</code>, <code>reconstruct()</code> and <code>update!()</code> functions. This facilitates building modular, composable structs while allowing access to solvers and optimisers that require flat vectors of parameters – or any other use case that requires extraction or modification of a list of values from a nested type. Importantly it&#39;s type-stable and <em>very</em> fast.</p><p>Flatten is also flexible. The types to use and ignore can be specified, and fields can be ignored using field level traits like <code>flattenable</code> from FieldMetadata.jl. Method overrides can also be defined for custom types.</p><p>Flatten allows &#39;querying&#39; to extract some types and ignore others, here using <code>flatten</code>:</p><pre><code class="language-julia-repl">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; struct Bar{X}
           x::X
       end

julia&gt; obj = Foo(1, :two, Foo(Bar(3), 4.0, 5.0f0));

julia&gt; use = Union{Int, Float32}; # Immediately return Int and AbstractFloat fields

julia&gt; ignore = Bar;  # Dont return Bar or iterate over Bar fields

julia&gt; flatten(obj, use, ignore) # Flatten all Int and Float32 except fields of Bar
(1, 5.0f0)

julia&gt; flatten(Foo(:one, :two, Foo(Bar(:three), 4.0, :five)), Symbol, Bar) # Return all symbols, except in Bar
(:one, :two, :five)</code></pre><p>The default type used is <code>Real</code>. These rules apply to all Flatten.jl functions.</p><p>Flatten.jl also uses <a href="https://github.com/rafaqz/FieldMetadata.jl">FieldMetadata.jl</a> to provide a <code>@flattenable</code> macro, allowing you to choose struct fields to include and remove from flattening – defaulting to <code>true</code> for all fields.</p><pre><code class="language-julia">using Flatten
import Flatten: flattenable

@flattenable struct Bar{X,Y}
    x::X | true
    y::Y | false
end

flatten(Bar(1, 2))

# output
(1,)</code></pre><p>Custom <code>@metadata</code> methods from FieldMetadata can be used, if they return a Bool. You can also use cusom functions that follow the following form, returning a boolean:</p><pre><code class="language-julia">f(::Type, ::Type{Var{:fieldname}}) = false</code></pre><p>Flatten also provides <code>metaflatten()</code> to flatten any FieldMetadata.jl metadata for the same fields <code>flatten()</code> returns. This can be useful for attaching information like descriptions or prior propability distributions to each field. Regular field data can also be collected with convenience versions of metaflatten: <code>fieldnameflatten</code>, <code>parentflatten</code>, <code>fieldtypeflatten</code> and <code>parenttypeflatten</code> functions provide lists of fieldnames and types that may be useful for building parameter display tables.</p><p>This package was started by Robin Deits (@rdeits), and its early development owes much to discussions and ideas from Jan Weidner (@jw3126) and Robin Deits.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L1-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.fieldnameflatten-Tuple{Any,Vararg{Any,N} where N}" href="#Flatten.fieldnameflatten-Tuple{Any,Vararg{Any,N} where N}"><code>Flatten.fieldnameflatten</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>jldoctest     fieldnameflatten(obj, args...)</p><p>Flatten the field names of an object. Args are passed to metaflatten.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; fieldnameflatten(Foo(1, 2, 3))
(:a, :b, :c)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L449-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.fieldtypeflatten-Tuple{Any,Vararg{Any,N} where N}" href="#Flatten.fieldtypeflatten-Tuple{Any,Vararg{Any,N} where N}"><code>Flatten.fieldtypeflatten</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fieldtypeflatten(obj, args...)</code></pre><p>Flatten the field types of an object. Args are passed to metaflatten.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; fieldtypeflatten(Foo(1.0, :two, &quot;Three&quot;), Union{Real,String})
(Float64, String)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L474-L493">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.flatten" href="#Flatten.flatten"><code>Flatten.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flatten(obj, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Flattening. Flattens a nested struct or tuple to a flat tuple. Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>data</code>: Replacement data - an <code>AbstractArray</code>, <code>Tuple</code> or type that defines <code>getfield</code>.</li><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadata method. With the form:</li></ul><pre><code class="language-julia">f(::Type, ::Type{Val{:fieldname}}) = true</code></pre><ul><li><code>use</code>: Type or <code>Union</code> of types to return in the tuple.</li><li><code>ignore</code>: Types or <code>Union</code> of types  to ignore completly. These are not reurned or recursed over.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; foo = Foo(1, 2, 3)
Foo{Int64,Int64,Int64}(1, 2, 3)

julia&gt; flatten(foo)
(1, 2, 3)

julia&gt; nested = Foo(Foo(1, 2, 3), 4.0, 5.0)
Foo{Foo{Int64,Int64,Int64},Float64,Float64}(Foo{Int64,Int64,Int64}(1, 2, 3), 4.0, 5.0)

julia&gt; flatten(nested)
(1, 2, 3, 4.0, 5.0)</code></pre><p>Fields can be excluded from flattening with the <code>flattenable(struct, field)</code> method. These are easily defined using <code>@flattenable</code> from <a href="https://github.com/rafaqz/FieldMetadata.jl">FieldMetadata.jl</a>, or defining your own custom function with FieldMetadata, or manually with the form:</p><pre><code class="language-julia">julia&gt; import Flatten: flattenable

julia&gt; @flattenable struct Partial{A,B,C}
           a::A | true
           b::B | true
           c::C | false
       end

julia&gt; nestedpartial = Partial(Partial(1.0, 2.0, 3.0), 4, 5)
Partial{Partial{Float64,Float64,Float64},Int64,Int64}(Partial{Float64,Float64,Float64}(1.0, 2.0, 3.0), 4, 5)

julia&gt; nestedpartial = Partial(Partial(1.0, 2.0, 3.0), 4, 5)
Partial{Partial{Float64,Float64,Float64},Int64,Int64}(Partial{Float64,Float64,Float64}(1.0, 2.0, 3.0), 4, 5)

julia&gt; flatten(nestedpartial)
(1.0, 2.0, 4)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L117-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.metaflatten" href="#Flatten.metaflatten"><code>Flatten.metaflatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">metaflatten(obj, func, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Metadata flattening. Flattens data attached to a field using a passed in function Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>func</code>: A function with the form: </li></ul><pre><code class="language-julia">f(::Type, ::Type{Val{:fieldname}}) = metadata</code></pre><ul><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadata method. With the form:</li></ul><pre><code class="language-julia">f(::Type, ::Type{Val{:fieldname}}) = true</code></pre><ul><li><code>use</code>: Type or <code>Union</code> of types to return in the tuple.</li><li><code>ignore</code>: Types or <code>Union</code> of types  to ignore completly. These are not reurned or recursed over.</li></ul><p>We can flatten the @foobar metadata defined earlier:</p><pre><code class="language-julia-repl">julia&gt; using Flatten, FieldMetadata

julia&gt; import Flatten: flattenable

julia&gt; @metadata foobar :foo;

julia&gt; @foobar struct Foo{A,B,C}
           a::A | :bar
           b::B | :foobar
           c::C | :foo
       end;

julia&gt; @foobar struct Bar{X,Y}
           x::X | :foobar
           y::Y | :bar
       end;

julia&gt; metaflatten(Foo(1, 2, Bar(3, 4)), foobar)
(:bar, :foobar, :foobar, :bar)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L368-L411">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.modify-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Flatten.modify-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Flatten.modify</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">modify(func, obj, args...)</code></pre><p>Modify field in a type with a function</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L283-L288">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.parentnameflatten-Tuple{Any,Vararg{Any,N} where N}" href="#Flatten.parentnameflatten-Tuple{Any,Vararg{Any,N} where N}"><code>Flatten.parentnameflatten</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parentnameflatten(obj, args...)</code></pre><p>Flatten the name of the parent type of an object. Args are passed to metaflatten.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; struct Bar{X,Y}
           x::X
           y::Y
       end

julia&gt; parentnameflatten(Foo(1, 2, Bar(3, 4)))
(:Foo, :Foo, :Bar, :Bar)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L500-L524">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.parenttypeflatten-Tuple{Any,Vararg{Any,N} where N}" href="#Flatten.parenttypeflatten-Tuple{Any,Vararg{Any,N} where N}"><code>Flatten.parenttypeflatten</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parenttypeflatten(obj, args...)</code></pre><p>Flatten the parent type of an object. Args are passed to metaflatten.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; struct Bar{X,Y}
           x::X
           y::Y
       end

julia&gt; parenttypeflatten(Foo(1, 2, Bar(3, 4)))
(Foo{Int64,Int64,Bar{Int64,Int64}}, Foo{Int64,Int64,Bar{Int64,Int64}}, Bar{Int64,Int64}, Bar{Int64,Int64})</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L530-L554">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.reconstruct" href="#Flatten.reconstruct"><code>Flatten.reconstruct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reconstruct(obj, data, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Reconstruct an object from Tuple or Vector data and an existing object. Data should be at least as long as the queried fields in the obj. Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>data</code>: Replacement data - an <code>AbstractArray</code>, <code>Tuple</code> or type that defines <code>getfield</code>.</li><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadata method. With the form:</li></ul><pre><code class="language-julia">f(::Type, ::Type{Val{:fieldname}}) = true</code></pre><ul><li><code>use</code>: Type or <code>Union</code> of types to return in the tuple.</li><li><code>ignore</code>: Types or <code>Union</code> of types  to ignore completly. These are not reurned or recursed over.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; reconstruct(Foo(1, 2, 3), (1, :two, 3.0))
Foo{Int64,Symbol,Float64}(1, :two, 3.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L212-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.update!" href="#Flatten.update!"><code>Flatten.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update!(obj, data, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Update a mutable object with a <code>Tuple</code> or <code>Vector</code> of data. Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>data</code>: Replacement data - an <code>AbstractArray</code>, <code>Tuple</code> or type that defines <code>getfield</code>.</li><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadat method. With the form:</li></ul><pre><code class="language-julia">f(::Type, ::Type{Val{:fieldname}}) = true</code></pre><ul><li><code>use</code>: Types to return in the tuple.</li><li><code>ignore</code>: Types to ignore completly. These are not reurned or recursed over.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Flatten

julia&gt; mutable struct MutableFoo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; mufoo = MutableFoo(1, 2, 3)
MutableFoo{Int64,Int64,Int64}(1, 2, 3)

julia&gt; update!(mufoo, (2, 4, 6))
MutableFoo{Int64,Int64,Int64}(2, 4, 6)

julia&gt; mufoo = MutableFoo(1, 2, :three)
MutableFoo{Int64,Int64,Symbol}(1, 2, :three)

julia&gt; update!(mufoo, (:four,), Symbol)
MutableFoo{Int64,Int64,Symbol}(1, 2, :four)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L291-L330">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flatten.constructor_of-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Flatten.constructor_of-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Flatten.constructor_of</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constructor_of(::Type)</code></pre><p>Add methods to define constructors for types with custom type parameters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/a3bd627333ee531cc968697a898b52e09e1bb4b7/src/Flatten.jl#L108-L111">source</a></section><footer><hr/></footer></article></body></html>
